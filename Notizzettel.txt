=============================================

Seminar Modern C++

Guten Morgen

Peter Loos

C/C++, Java,  C#,  JavaScript, ( Python ), Mobile Programming

Back-to-the-Roots:  C/C++

=============================================

Github

https://github.com/pelocpp

==============================================

2 Tools:

== Visual C++ ( Community 2022 )

== Github:  pelocpp  // Modern Cpp

==============================================

12.30 Mittagspause

Kaffeepausen

Bis 17.00 

==============================================

ToDo-Liste:

noexept

==============================================


Erwartungen

Was muss drin sein !!!

Überblick

Fehlt was ???

( Qt ),  WinForms, WPF, Swing ...

Fragen: 

==============================================

Agenda

Roten Faden - Überblick - Systematisierung

==============================================

Referenz:  Hinter den Kullisen:  Adresse / Zeiger

           NICHT änderbar.

           Anschauliche Defintion:  Eine Referenz ist ein ALIAS.

           Es gibt einen ZWEITEN Namen für das Objekt (Variable).

sayHello(a + b);  // +:  Konkatenation: "Hello World"

a ist nicht temporär und hat einen Namen

a + b ist ein temp. Objekt
a + b hat keine expl. Namen.

C++ 11:

Um Performanz zu steigern:

Es gibt eine neuen, zweiten Typus von Referenzen: std::string &&

Dieser Typus von Referenzen ist definiert für temp. Objekte.


Namensgebung:  C

Wertzuweisung:

        a = b;
        a = 10 + 12;
 Adresse  = Wert

  LValue  = RValue


int&:     LValue-Referenz // Adresse

int&&:    RValue-Referenz // Werte / Temp. Objekt

          KEINEN Namen, anonym ....

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy  ===> Move-Semantik

========================================================

Move-Semantik:

... 090   // Objekt am Stack // temporär // wird freigegeben
... 640   // Objekt im Vektor


... 720


... 210


Kopier-Konstruktor
------------------

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/RuleOfThree.md

Bit-weises Kopieren eines Objekts: Wird automatisch beigestellt.

Achtung: Problem des doppelten delete ( double delete // double free )


Vor C++ 11 Periode:  push_back ist "teuer" // 2 Objekte 

Ab C++ 11: Move-Semantik: 2 neue Methoden.

((
    Kopieren:       Kopier-Konstruktor
    Wertzuweisung:  operator=
))

====================================================

// old, "classical" syntax
std::string toString(int value);

// new syntax with trailing return type
auto toString(int value) -> std::string;

Whyyyyyyyyyyyyyyyyyyyyyyyy:  3 Minuten

====================================================

Lambda:

Vorbemerkung 1:  Historisch  ==> Verständnis.

Vorbemerkung 2:  "Lambda-Funktion"

                 Exakt: Ein Lambda ist ein OBJEKT.

Beispiel:

Sortieren  ==> std::sort  // Iteratoren (grob)

// -----------------------------------------------

The signature of the comparison function should be equivalent
to the following:

bool cmp(const Type1& a, const Type2& b);

The signature does not need to have const&: Whyyyy ???

Performanz:

a) Vektor von OBJEKTEN:

   ==> Keine Kopien, sondern Referenzen.

a) Vektor von elem. Datentypen (int / double):

  Vergleich:

      static bool compare (int n1, int n2) {

        int m = n1;
00007FF7646AC405  mov         eax,dword ptr [n1]  
00007FF7646AC40B  mov         dword ptr [m],eax  

      static bool compare (int& n1, int n2) {

        int m = n1;
00007FF69CFEC415  mov         rax,qword ptr [n1]  // rax ist ein Adress-Register
00007FF69CFEC41C  mov         eax,dword ptr [rax]  
00007FF69CFEC41E  mov         dword ptr [m],eax  



"Aufrufbares Objekt" // Callable // Funktor

Stammt von Klassen, die einen bestimmten Operator überladen:

operator()

Whyyyyyyyyy ... ist sehr ähnlich  zu einer Methode einer Klasse

Very easy: Man bekommt eine Methode ... und
ich muss dieser Methode KEINEN NAMEN geben.

Historisch:

a) freie Funktion

b) Aufrufbares Objekt (Klasse mit Operator () )

c) Ähnlich zu b) -- Die Klasse liegt "nahe" bei ihrer Verwendung


Was ist ein Lambda ???????

Ein Lambda ist ein Objekt - ohne Namen - eine Klasse,
die ebenfalls anonym ist, und die im Kontext der aktuellen Funktion/Methode
definiert wird und die den Aufrufoperator operator() implementiert.

Die Parameter des  operator() sind ebenfalls im Lambda zu definieren.

--------------------------

        std::sort(
            vec.begin(),
            vec.end(),
            [] (int n1, int n2) {
                std::cout << "Lambda vgl. " << n1 << " mit " << n2 << std::endl;
                return n1 < n2;
            }
        );

Was ist ein Lambda ?

a) Einfach formuliert:

Eine Funktion, die inline / anonym hingeschrieben wird.

b) Besser formuliert:

Ein Objekt eine Klasse (anonym),
das den operator() implementiert.

Wozu:

Es ist besser zu Lesen / zu Warten,
wenn Funktionalität "an einem Ort" steht.

Block hinter die Kulissen:

Tool ==> Cpp Insights.

https://cppinsights.io/

==========================================

        int intArrayFrage[10]{ };
00007FF66DDFA5EE  lea         rax,[intArrayFrage]  
00007FF66DDFA5F2  mov         rdi,rax  
00007FF66DDFA5F5  xor         eax,eax  
00007FF66DDFA5F7  mov         ecx,28h  
00007FF66DDFA5FC  rep stos    byte ptr [rdi]  

==========================================


std::weak_ptr 

==========================================

STL:

Container:   std::vector // std::map ...

Algorithmen:

std::fill, std::copy, std::transform, std::for_each, ....

std::vector :  reserve  // Capacity

==========================================

Algorithmen:
============

Vektor:

Neue Kap. == Alte Lap. * 1.5;

Merke: Go for 'reserve'

=========================================

STL:
====

== Container

== Iteratoren (Positionen)

== Algorithmen

Bemerkung:  Zugriff auf einen Container mit operator[]:

    Geht nur bei sequentiellen Container:
    
         Da liegen im Speicher alle DATEN am STÜCK hintereinander.

Zugriff auf einen Container: Mit dem Konzept einer "Position"

    Lösung: Wie komme ich von einem Element zum Nächsten ???

Auch für Positionen (Iterator) gibt es ein Regelwerk:

operator++  : gehe zur nächsten Position

operator*:    gib das Element an dieser Position zurück

operator== oder !=:   Vergleiche zwei Positionen


========================================================

3-Einigkeit: STL

== Container

     ||

== Iteratoren (Positionen)

     ||

== Algorithmen


Vergleich:

Wie kann man den Inhalt eines Containers (std::vector) vorbelegen ????

============================

Andere Sprachen // junge Menschen:  for each

Auch in C++:  for

Go for STL Algorithms ==> kann nur schneller werden :)

Morgen: 2. Block.

============================

Betrachtungen zur Performanz // STL

std::vector

std::array (C-Style Array)

================================================

Smart Pointer
-------------

std::unique_ptr

std::shared_ptr
std::weak_ptr

Aussage: Smart Pointer kümmern sich um das 'delete'

Wie?

Idee:

Alle Smart Pointer sind OBJEKTE

==> Konstruktoren
    Destruktoren


    {
         Smart Pointer  sp ();    // new

         ...

    }    Destruktor von sp;   // deterministisch // Aktionen: delete // Referenzzähler (delete)

=================================================

Debug - Modus:

3 spezielle Werte im Speicher:

CC - Stack, nicht initialisiert

CD - Heap, nicht initialisiert

DD - Heap, bereits freigegeben

=================================================

Wozu std::weak_ptr ???

Was ist das Problem ???

std::shared_ptr:  Hmmmm, dieser funktioniert nicht immer ?!?!?!?!?!?!?!?!

==> Es wird nicht immer delete aufgerufen !!!!!!!!!!!

a) std::weak_ptr : Wie funktioniert dieser

b) Was ist das Problem genau !!!

   Zyklen.   (  Bildchen   )

   Glück gehabt - habe ich nicht:  Voooooooooooooooooooooorsicht !!!

Frage:

Observer - Pattern:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Observer/Resources/Readme.md

Was tut das ???

Es gibt ein Objekt mit relevanten Zustandsdaten:  Aktienkurse, Wetterdaten:

Subject, Ereignis Quelle (Event Source)

==> Beobachten:  Polling - Ginge - Aber ist ineffizient.

== Beobachter (Observer) melden sich an der Ereignis Quelle an.

== Die Ereignis Quelle speichert die Beobachter in einer Liste ab.



A) Ein (mehrere) Beobachter kennen die Ereignis Quelle.

B) Eine Ereignis Quelle kennt Beobachter (Liste)

========> Hier ist ein Zyklus vorhanden.

I) Ereignis Quelle:  std::shared_ptr   // Besitzer

    // Optional: Es könnte (datentechnisch) auch mehrere Besitzer geben.

II) Beobachter (Observer):   std::shared_ptr  // Besitzer

       Braucht man dieses Objekt (Beobachter) nicht mehr: std::shared_ptr
       
       geht Out-of-Scope

III) In der Ereignis Quelle gibt es eine Liste von Beobachtern:

    Von welchem Typ sollten die Elemente in dieser Liste sein ???????????????

    ==> std::weak_ptr

    Theoretisch / SW-technisch:  std::shared_ptr 

    Eine Ereignis Quelle sollte KEIN Besitzer ihrer Observer sein !!!!

Fazit:

std::shared_ptr:    Besitzer
std::weak_ptr

Visualisierung:     Bauteile / Buchungen / Aktienkurse

==> std::weak_ptr:  i) Die Visualisierung ist kein Besitzer des o.a. Objekts

die Visualisierung muss etwas flexibler programmiert werden:

a) std::weak_ptr => lock => std::shared_ptr:

b) Was ist, wenn std::shared_ptr == nullptr (empty)

Ich will das nicht :-)  Dann werden Objekte, die eigentlich keinen echten Besitzer haben,
      nicht aus dem Speicher genommen, weil es noch andere Besitzer gibt.


nur std::shared_ptr: bad.

Mal sollte std::weak_ptr mit ins Spiel bringen.


Fazit: Unterscheidung: Besitzer <=> kein Besitzer.

Diese Thematik ist KEIN reines C++ Problem:

C# // Garbage Collected // Referenz-Counting.

Java: 

=======================================================

std::initializer_list:   ===> Stack   // KEIN new / delete 

std::vector:             ===> Heap    // mit new / delete / reallokation

Performanz:   Go-for std::initializer_list (zB bei Parameterübergabe)

std::initializer_list:

Ist kein vollwertiger STL Container

Leichtgewichtig // Light weight:

== begin()
== end()
== size()

Zum Sequenz-Konstruktor:

std::vector<int> vec( 10 );  // Size: 10 - Inhalt: 10 mal 0
vs.
std::vector<int> vec{ 10 };  // Size: 1  - Inhalt: einmal 10 

Nur bei std::vector:

std::vector<int> vec( 10, 20 );  // Size: 10 - Inhalt: 10 mal 20
vs.
std::vector<int> vec{ 10, 20 };  // Size: 2  - Inhalt: 10 und 20 

====================================================

Generische Funktionen:

"auto zum Ersten":

  Vereinbarung von Variablen


"auto zum Zweiten"

  Deklaration des Rückgabetyps


"auto zum Dritten"

  Definition eines Parameters mit auto

==============================

Wie sieht der C++ Compiler eine generische Funktion?

    static void function(auto x, int y) {
        std::cout << "x=" << x << ", y=" << y << std::endl;
    };

Umsetzung auf Bekanntes:

=============================================

std::pair  ==> std::tuple

  2        ==>     n Elemente


Ein std::tuple ist ähnlich zu einer Struktur
für Schreibfaule :)

Das kann  man ändern .... mit Structured Binding:

Eigentlich sind wir jetzt an Strukturen sehr nah dran ==> Namen.


Go for std::tuple

=============================================

Array:

Was ist ein Array:

Eine Menge an Daten desselben Typs (Speicher zusammenhängend), FIXED Size.

C:     int numbers[10];

C++:   int numbers[10];   // C-Stil

       std::array<int, 10> numbers;    // C++ - Klasse // C++ Stil

Hmmm: C ist in C++ enthalten (98%).

Ein C-Array hat Vor- und Nachteile:

int numbers[10];

int n = calcIndex();

int value = numbers[n];  // a) n ist zwischen 0 und 9 (inkl.): passt

                         // b) n ist NICHT zwischen 0 und 9 (inkl.): Man greift "irgendwo" hin

i) Performanz

ii) A Programmer knows what he does.   // Dennis Ritchie 

Vorteil von std::array:

int value = numbers[n];       // ohne Überprüfung (Performanz)

int value = numbers.at(n);    // mit Überprüfung // Robustheit // Exception


===============================================================

std::array             //  zusammenhängenden Speicher  // data() // size()
std::vector            //  zusammenhängenden Speicher  // data() // size()

Helfer:

std::span // Spanne

Woraus besteht ein Objekt des Typs std::span  :  T* ( data()  ) UND Size ( size()  )

Felder:

Go - for - std::array: Daten FIXED-Size.

Go - for - std::span:   C++ 20


======================================================

SSO

std::string

foo ()
{
    std::string s ("111111111111111111111111111111111111111111111111");
}

======================================================

const char* s = "111111111111111111111111111111111111111111111111";

Wo liegt in einem C++ Programm diese Zeichenkette ???

NICHT am HEAP !!!  No new !!!!!

.BSS   // eher nicht, weil initialisiert.
.DATA  // Jepp 1
.TEXT  // Jepp 2 , obwohl dass das Code Segment ist :)

Was ist das Ziel ??? // Was ist das Thema ???

Betrachtung konstanter Zeichenketten: 

Müssen / sollen konstante Zeichenketten am Heap abgelegt werden:

NEIN. 

VORSICHT: std::string legt diese auf den Heap.

ABER:

std::string_view: Diese legt die Zeichenkette NICHT auf den Heap.

Go for std::string_view , wenn ihr nicht explizit Zeichenkettenverarbeitung
machen müsst.

Ein std::string_view Objekt ist ein NON-OWNING Objekt.

===========================================================

Wer ist std::variant ???

Eine Variable / ein Objekt, das Daten unterschiedlichen Typs aufnehmen kann,
zu einem Zeitpunkt aber nur EINEN Wert.

Beispiel:

Excel // Google Sheets:

Zelle // cell:  ==> Zeichenkette, num. Wert, Datum, Currency, ...

Ähnlichkeit: Union 

Feature:

Man kann einen std::variant "besuchen"

std::visit

===========================================================

Baukasten:

Metaprograming ==> Programmierung zur Übersetzungszeit.

Type Traits

if constexpr  =============> Ein if des Übersetzers:
